<p>Specifying a Deployment for Platform Types</p><br><p>Items within SAP Commerce are made persistent by writing values
    into a database. Within the database, the values are stored in tables. SAP Commerce allows you to explicitly define
    the database tables where the values of instances of a given type will be written. This process is referred to as
    deployment.</p><br><br><p>Technical Background</p><br><p>SAP Commerce stores instances of types in tables within a
    database. Every instance is stored as one row in a database table.</p><br><br><p>The table within a database where
    instances of a type are stored is called the type deployment and is specified with the type itself. Every type needs
    to have a deployment to store its instances. Deployment is inherited from a type to its subtypes. The deployment
    that is active for a given type is the deployment specified closest to the type in the type's hierarchy. The topmost
    deployment is GenericItem, which is therefore the default deployment. This means if a type has no explicit
    specification of deployment, that type's instances are deployed in the same table as GenericItem.</p><br><br><p>This
    means that the default deployment of any subtype, which you extend from GenericItem, is the deployment of
    GenericItem. In other words: if you do not specify a deployment for a subtype of GenericItem, the instances of that
    subtype are stored in the same table as instances of GenericItem.</p><br><br><p>For example, the Catalog and CronJob
    types in SAP Commerce are subtypes of GenericItem. If there were no deployment specified for Catalog and CronJob,
    all Catalog and CronJob instances are written into one single database table. Firstly, this is not intuitive.
    Secondly, storing instances of many different types in one single database table causes that database table to have
    quite a lot of columns to store all attributes from all these types (a CronJob has different attributes than a
    Catalog, and both types need to store attribute values).</p><br><br><p>Note</p><br><p>Specify Deployment for All
    Types</p><br><br><p>Deployment of a large number of types in a single table can markedly decrease the performance.
    Therefore, by default, builds fail if you do not specify the deployment table and you may encounter errors such
    as:</p><br><br>
<p>[ycheckdeployments] No deployment defined for relation
    <RELATIONNAME> in file:
        <FILENAME>
</p><br><p>Otherwise it would be easy to forget to specify the deployment, and, as a result, some types would go to the
    GenericItem table. The build failure reminds you that deployment is not specified for some types. To change this
    default behaviour, set the property build.development.mode to false in the local.properties file:</p><br><br><p>
    build.development.mode=false</p><br><br><p>Setting this value to false is useful for some legacy projects that
    keep all items in default tables (genericitems, links).</p><br><br><p>Keeping individual types' instances deployed
    in different tables keeps the number of columns down to a minimum.</p><br><br><p>By consequence, SAP recommends
    specifying a deployment for direct subtypes of GenericItem only. Subtypes of subtypes of GenericItem usually do not
    need a specific deployment as the number of database table columns in the deployment is not likely to get out of
    hand. In constrast, specifying a deployment for a subtype whose supertype has a deployment already is likely to
    reduce database performance (especially during long and complex database transactions, such as synchronization
    between catalog versions).</p><br><br><br><p>For example, let's assume you extend myType1 and myType2 from
    GenericItem. Then it is recommended for myType1 and for myType2 to have a specific deployment (to avoid having their
    instances stored in the GenericItem database table).</p><br><br><p>A subtype of myType1 or myType2 (for example,
    myType3 in the diagram) is not likely to also need a specific deployment. The instances of myType3 fit into the
    myType2 type's tables without any negative side effects. In fact, running FlexibleSearch statements on myType2
    requires JOINs to include the myType3 type as well. The more deployments there are within a type hierarchy, the more
    JOINs in a database statement are necessary, and the longer complex database actions take to complete.</p><br><br>
<p>In other words:</p><br><br><p>If you create a subtype of GenericItem, use a deployment.</p><br><p>If you create a
    subtype of Product, which is a subtype of GenericItem already, using a specific deployment is discouraged by SAP. It
    is technically possible to use a deployment for subtypes whose supertypes already have an individual deployment, but
    it is not recommended. The JOINs required to construct database statements reduce performance.</p><br><p>Solution:
    Defining a Deployment in SAP Commerce</p><br><p>Note</p><br><p>Database Limitations Apply</p><br><br><p>This form of
    specifying a deployment is affected by database limitations, which you have to comply with. Therefore, Platform only
    allows a deployment string of 24 characters maximum.</p><br><br><p>For example, Oracle databases only allow a
    maximum of 30 characters overall for the table attribute value.</p><br><br><p>This 30-character limit includes table
    prefixes. So if you use a table prefix of myDataBase (for a total of 10 characters), you have only 20 characters
    left for the table attribute value.</p><br><br>
<p>To specify a deployment, add a
    <deployment table="tablename" typecode="typecode_number"/>
    tag to the type definition in the items.xml file:
</p><br><br><p>Open the items.xml in your extension.</p><br><p>Locate the type definition where you want to specify a
    deployment, such as</p><br>
<p>
    <itemtype code="MyItem" extends="GenericItem">
</p><br>
<p>
    <attribute qualifier="myAttribute" ...>
</p><br><p> ...</p><br></itemtype><br><br>
<p>Add the
    <deployment> tag nested into the item definition. You need to specify a value for the deployment and the typecode
        attributes :
</p><br>
<p>
    <deployment table="mytype_deployment"/>
</p><br><br><p>The deployment attribute specifies the table name into which the instances of the type are written, such
    as table="mytype_deployment"</p><br><br><p>The typecode attribute must specify a unique number to reference the
    type. The value of the typecode attribute must be a positive integer between 0 and 32767 (2^15-1) and must be unique
    throughout SAP Commerce as it is part of the PK generation mechanism. Typecode values between 0 and 10000 are
    reserved for SAP Commerce-internal use. Typecode values larger than 10000 are generally free for you to use but
    there are lots of exceptions to that rule.</p><br><br><p>Note</p><br><p>Not all typecode values larger than 10000
    are free for you to use. There are many exceptions. Here are some examples:</p><br><br><p>commons extension
    (132xx)</p><br><br><p>processing extension (327xx)</p><br><br><p>Legacy xprint extension (244xx,245xx)</p><br><br>
<p>b2bcommerce extension (100xx)</p><br><br>
<p>For a full list of exceptions, see the
    <HYBRIS_BIN_DIR>/platform/ext/core/resources/core/unittest/reservedTypecodes.txt file.
</p><br><br><p>The entire type definition might look like this:</p><br><br>
<p>
    <item code="MyItem" extends="GenericItem">
</p><br>
<p>
    <deployment table="mytype_deployment" typecode="12345"/>
</p><br>
<p>
    <attribute name="myAttribute" ...>
</p><br><p> ...</p><br></item><br><br><p>Using a typecode that is already is use causes SAP Commerce to fail the build
    with the error message due to duplicate deployment code, as in:</p><br><br>
<p>[java] java.lang.IllegalArgumentException: cannot merge namespace ((customerreview)) into ((
    <merged>)) due to duplicate deployment code '1052' :
</p><br><p>
    de.hybris.platform.persistence.customerreview_CustomerReview::((customerreview))::YDeployment[customerreview.items.xml:51(ItemTypeTagListener)]<></p>
<br><p>
    de.hybris.platform.persistence.europe1_DiscountRow::((europe1))::YDeployment[europe1.items.xml:150(ItemTypeTagListener)]</p>
<br><br><p>Specifying or Changing Deployment for Relations</p><br><p>There are two important facts related to deployment
    for relations.</p><br><br><p>Firstly, you must specify a deployment for m:n relation, otherwise Platform will not
    build. Previously it was allowed to define an m:n relation which had no deployment. The relation was then maintained
    by the Links table. If there were multiple relations without a specified deployment, they all resided in the Links
    table. This caused bad performance and is not a good practice. Therefore, whenever you try to define an m:n relation
    without a deployment, initialisation fails with the following error:</p><br><br>
<p>[ycheckdeployments] No deployment defined for relation
    <RELATIONNAME> in file:
        <FILENAME>
</p><br><br><p>Secondly, bear in mind that Platform does not allow changing an existing deployment. This is done in
    order to protect data. If there were already some records in current deployment of a type or relation, and the
    deployment would get changed afterwards, then access would be lost to all those records.</p><br><br><p>This has a
    special consequence in conjunction with the previous paragraph (specifying a deployment), because if an m:n relation
    did not have a deployment before, and now (according to best practices) someone wants to assign it a deployment,
    this change will not be performed.</p><br><br><p>Every time Platform refuses to make a deployment change, one of the
    following messages is printed:</p><br><br><p>If there was no deployment before:</p><br>
<p>Addition of the deployment for type
    <TYPECODE> from
        <OLDDEPLOYMENT> to
            <NEWDEPLOYMENT> will not be performed; be aware that the old deployment will be still used (even though it
                is not reflected in the code base).
</p><br><br><p>If there was another deployment defined before:</p><br>
<p>Modification of the deployment for type
    <TYPECODE> from
        <OLDDEPLOYMENT> to
            <NEWDEPLOYMENT> will not be performed; be aware that the old deployment will still be used (even though it
                is not reflected in the code base).
</p><br><br><p>Using a Custom Property Table</p><br><p>If you want to use an own propertytable, you have to specify an
    own extensionname-advanced-deployment.xml in the resource folder of your extension. To use the table testtable, you
    would need the content of this file like this:</p><br><br>
<p>
    <model name="hybris" description="...">
</p><br>
<p>
    <package name="de.hybris.jakarta.session" description="all session beans">
</p><br>
<p>
    <package name="de.hybris.jakarta.session.property">
</p><br><br>
<p>
    <object name="Property">
</p><br>
<p>
    <object-mapping>
</p><br><p>
<table name="testtable"/></p><br>
<p>
    <index name="ITEMPK">
</p><br>
<p>
    <index-key attribute="itemPK"/>
</p><br><p>                    </index></p><br>
<p>
    <index name="NAMEIDX">
</p><br>
<p>
    <index-key attribute="name"/>
</p><br><p>                    </index></p><br><p>               </object-mapping></p><br>
<p>
    <attribute name="itemPK" type="HYBRIS.PK" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="ITEMPK" null-allowed="false"/>
</p><br><p>                    </attribute></p><br>
<p>
    <attribute name="itemTypePK" type="HYBRIS.PK">
</p><br>
<p>
    <attribute-mapping persistence-name="ITEMTYPEPK" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="name" type="java.lang.String" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="NAME" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="langPK" type="HYBRIS.PK" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="LANGPK" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="realName" type="java.lang.String">
</p><br>
<p>
    <attribute-mapping persistence-name="REALNAME"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="type1" type="int">
</p><br>
<p>
    <attribute-mapping persistence-name="TYPE1"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="valueString1" type="HYBRIS.LONG_STRING">
</p><br>
<p>
    <attribute-mapping database="sqlserver" persistence-name="VALUESTRING1" persistence-type="nvarchar(1800)"/>
</p><br>
<p>
    <attribute-mapping database="oracle" persistence-name="VALUESTRING1" persistence-type="varchar2(4000)"/>
</p><br>
<p>
    <attribute-mapping persistence-name="VALUESTRING1"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="value1" type="java.io.Serializable">
</p><br>
<p>
    <attribute-mapping persistence-name="VALUE1"/>
</p><br>
<p>
    <attribute-mapping database="oracle" persistence-name="VALUE1" persistence-type="LONG RAW"/>
</p><br><p>               </attribute></p><br><p>            </object></p><br><p></p><br><p>         </package></p><br>
<br></package><br></model><br><br><p>SAP Commerce contains the Maintenance Deployment page in Administration Console
    that gives an overview of the typecodes and the deployments in use.</p><br><br><p>Advanced Deployment</p><br><p>To
    see how SAP Commerce types are mapped to different databases, see the file
    bin/platform/ext/core/resources/core-advanced-deployment.xml.</p><br><br>
<p>
    <database-schema database="hsqldb" primary-key="primary key" null="" not-null="not null">
</p><br>
<p>
    <type-mapping type="java.lang.String" persistence-type="VARCHAR(255)"/>
</p><br>
<p>
    <type-mapping type="String" persistence-type="VARCHAR(255)"/>
</p><br><br>
<p>
    <type-mapping type="java.lang.Float" persistence-type="float"/>
</p><br>
<p>
    <type-mapping type="java.lang.Double" persistence-type="double"/>
</p><br>
<p>
    <type-mapping type="java.lang.Byte" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Character" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Short" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Boolean" persistence-type="tinyint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Long" persistence-type="bigint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Integer" persistence-type="int"/>
</p><br><br>
<p>
    <type-mapping type="float" persistence-type="float default 0"/>
</p><br>
<p>
    <type-mapping type="double" persistence-type="double default 0"/>
</p><br>
<p>
    <type-mapping type="byte" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="char" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="short" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="boolean" persistence-type="tinyint default 0"/>
</p><br>
<p>
    <type-mapping type="long" persistence-type="bigint default 0"/>
</p><br>
<p>
    <type-mapping type="int" persistence-type="int default 0"/>
</p><br><br>
<p>
    <type-mapping type="java.util.Date" persistence-type="timestamp"/>
</p><br>
<p>
    <type-mapping type="java.math.BigDecimal" persistence-type="DECIMAL(30,8)"/>
</p><br>
<p>
    <type-mapping type="java.io.Serializable" persistence-type="longvarbinary"/>
</p><br><br>
<p>
    <type-mapping type="HYBRIS.LONG_STRING" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.JSON" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.COMMA_SEPARATED_PKS" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.PK" persistence-type="BIGINT"/>
</p><br><br><p>    </database-schema>Specifying a Deployment for Platform Types</p><br><p>Items within SAP Commerce are
    made persistent by writing values into a database. Within the database, the values are stored in tables. SAP
    Commerce allows you to explicitly define the database tables where the values of instances of a given type will be
    written. This process is referred to as deployment.</p><br><br><p>Technical Background</p><br><p>SAP Commerce stores
    instances of types in tables within a database. Every instance is stored as one row in a database table.</p><br><br>
<p>The table within a database where instances of a type are stored is called the type deployment and is specified with
    the type itself. Every type needs to have a deployment to store its instances. Deployment is inherited from a type
    to its subtypes. The deployment that is active for a given type is the deployment specified closest to the type in
    the type's hierarchy. The topmost deployment is GenericItem, which is therefore the default deployment. This means
    if a type has no explicit specification of deployment, that type's instances are deployed in the same table as
    GenericItem.</p><br><br><p>This means that the default deployment of any subtype, which you extend from GenericItem,
    is the deployment of GenericItem. In other words: if you do not specify a deployment for a subtype of GenericItem,
    the instances of that subtype are stored in the same table as instances of GenericItem.</p><br><br><p>For example,
    the Catalog and CronJob types in SAP Commerce are subtypes of GenericItem. If there were no deployment specified for
    Catalog and CronJob, all Catalog and CronJob instances are written into one single database table. Firstly, this is
    not intuitive. Secondly, storing instances of many different types in one single database table causes that database
    table to have quite a lot of columns to store all attributes from all these types (a CronJob has different
    attributes than a Catalog, and both types need to store attribute values).</p><br><br><p>Note</p><br><p>Specify
    Deployment for All Types</p><br><br><p>Deployment of a large number of types in a single table can markedly decrease
    the performance. Therefore, by default, builds fail if you do not specify the deployment table and you may encounter
    errors such as:</p><br><br>
<p>[ycheckdeployments] No deployment defined for relation
    <RELATIONNAME> in file:
        <FILENAME>
</p><br><p>Otherwise it would be easy to forget to specify the deployment, and, as a result, some types would go to the
    GenericItem table. The build failure reminds you that deployment is not specified for some types. To change this
    default behaviour, set the property build.development.mode to false in the local.properties file:</p><br><br><p>
    build.development.mode=false</p><br><br><p>Setting this value to false is useful for some legacy projects that
    keep all items in default tables (genericitems, links).</p><br><br><p>Keeping individual types' instances deployed
    in different tables keeps the number of columns down to a minimum.</p><br><br><p>By consequence, SAP recommends
    specifying a deployment for direct subtypes of GenericItem only. Subtypes of subtypes of GenericItem usually do not
    need a specific deployment as the number of database table columns in the deployment is not likely to get out of
    hand. In constrast, specifying a deployment for a subtype whose supertype has a deployment already is likely to
    reduce database performance (especially during long and complex database transactions, such as synchronization
    between catalog versions).</p><br><br><br><p>For example, let's assume you extend myType1 and myType2 from
    GenericItem. Then it is recommended for myType1 and for myType2 to have a specific deployment (to avoid having their
    instances stored in the GenericItem database table).</p><br><br><p>A subtype of myType1 or myType2 (for example,
    myType3 in the diagram) is not likely to also need a specific deployment. The instances of myType3 fit into the
    myType2 type's tables without any negative side effects. In fact, running FlexibleSearch statements on myType2
    requires JOINs to include the myType3 type as well. The more deployments there are within a type hierarchy, the more
    JOINs in a database statement are necessary, and the longer complex database actions take to complete.</p><br><br>
<p>In other words:</p><br><br><p>If you create a subtype of GenericItem, use a deployment.</p><br><p>If you create a
    subtype of Product, which is a subtype of GenericItem already, using a specific deployment is discouraged by SAP. It
    is technically possible to use a deployment for subtypes whose supertypes already have an individual deployment, but
    it is not recommended. The JOINs required to construct database statements reduce performance.</p><br><p>Solution:
    Defining a Deployment in SAP Commerce</p><br><p>Note</p><br><p>Database Limitations Apply</p><br><br><p>This form of
    specifying a deployment is affected by database limitations, which you have to comply with. Therefore, Platform only
    allows a deployment string of 24 characters maximum.</p><br><br><p>For example, Oracle databases only allow a
    maximum of 30 characters overall for the table attribute value.</p><br><br><p>This 30-character limit includes table
    prefixes. So if you use a table prefix of myDataBase (for a total of 10 characters), you have only 20 characters
    left for the table attribute value.</p><br><br>
<p>To specify a deployment, add a
    <deployment table="tablename" typecode="typecode_number"/>
    tag to the type definition in the items.xml file:
</p><br><br><p>Open the items.xml in your extension.</p><br><p>Locate the type definition where you want to specify a
    deployment, such as</p><br>
<p>
    <itemtype code="MyItem" extends="GenericItem">
</p><br>
<p>
    <attribute qualifier="myAttribute" ...>
</p><br><p> ...</p><br></itemtype><br><br>
<p>Add the
    <deployment> tag nested into the item definition. You need to specify a value for the deployment and the typecode
        attributes :
</p><br>
<p>
    <deployment table="mytype_deployment"/>
</p><br><br><p>The deployment attribute specifies the table name into which the instances of the type are written, such
    as table="mytype_deployment"</p><br><br><p>The typecode attribute must specify a unique number to reference the
    type. The value of the typecode attribute must be a positive integer between 0 and 32767 (2^15-1) and must be unique
    throughout SAP Commerce as it is part of the PK generation mechanism. Typecode values between 0 and 10000 are
    reserved for SAP Commerce-internal use. Typecode values larger than 10000 are generally free for you to use but
    there are lots of exceptions to that rule.</p><br><br><p>Note</p><br><p>Not all typecode values larger than 10000
    are free for you to use. There are many exceptions. Here are some examples:</p><br><br><p>commons extension
    (132xx)</p><br><br><p>processing extension (327xx)</p><br><br><p>Legacy xprint extension (244xx,245xx)</p><br><br>
<p>b2bcommerce extension (100xx)</p><br><br>
<p>For a full list of exceptions, see the
    <HYBRIS_BIN_DIR>/platform/ext/core/resources/core/unittest/reservedTypecodes.txt file.
</p><br><br><p>The entire type definition might look like this:</p><br><br>
<p>
    <item code="MyItem" extends="GenericItem">
</p><br>
<p>
    <deployment table="mytype_deployment" typecode="12345"/>
</p><br>
<p>
    <attribute name="myAttribute" ...>
</p><br><p> ...</p><br></item><br><br><p>Using a typecode that is already is use causes SAP Commerce to fail the build
    with the error message due to duplicate deployment code, as in:</p><br><br>
<p>[java] java.lang.IllegalArgumentException: cannot merge namespace ((customerreview)) into ((
    <merged>)) due to duplicate deployment code '1052' :
</p><br><p>
    de.hybris.platform.persistence.customerreview_CustomerReview::((customerreview))::YDeployment[customerreview.items.xml:51(ItemTypeTagListener)]<></p>
<br><p>
    de.hybris.platform.persistence.europe1_DiscountRow::((europe1))::YDeployment[europe1.items.xml:150(ItemTypeTagListener)]</p>
<br><br><p>Specifying or Changing Deployment for Relations</p><br><p>There are two important facts related to deployment
    for relations.</p><br><br><p>Firstly, you must specify a deployment for m:n relation, otherwise Platform will not
    build. Previously it was allowed to define an m:n relation which had no deployment. The relation was then maintained
    by the Links table. If there were multiple relations without a specified deployment, they all resided in the Links
    table. This caused bad performance and is not a good practice. Therefore, whenever you try to define an m:n relation
    without a deployment, initialisation fails with the following error:</p><br><br>
<p>[ycheckdeployments] No deployment defined for relation
    <RELATIONNAME> in file:
        <FILENAME>
</p><br><br><p>Secondly, bear in mind that Platform does not allow changing an existing deployment. This is done in
    order to protect data. If there were already some records in current deployment of a type or relation, and the
    deployment would get changed afterwards, then access would be lost to all those records.</p><br><br><p>This has a
    special consequence in conjunction with the previous paragraph (specifying a deployment), because if an m:n relation
    did not have a deployment before, and now (according to best practices) someone wants to assign it a deployment,
    this change will not be performed.</p><br><br><p>Every time Platform refuses to make a deployment change, one of the
    following messages is printed:</p><br><br><p>If there was no deployment before:</p><br>
<p>Addition of the deployment for type
    <TYPECODE> from
        <OLDDEPLOYMENT> to
            <NEWDEPLOYMENT> will not be performed; be aware that the old deployment will be still used (even though it
                is not reflected in the code base).
</p><br><br><p>If there was another deployment defined before:</p><br>
<p>Modification of the deployment for type
    <TYPECODE> from
        <OLDDEPLOYMENT> to
            <NEWDEPLOYMENT> will not be performed; be aware that the old deployment will still be used (even though it
                is not reflected in the code base).
</p><br><br><p>Using a Custom Property Table</p><br><p>If you want to use an own propertytable, you have to specify an
    own extensionname-advanced-deployment.xml in the resource folder of your extension. To use the table testtable, you
    would need the content of this file like this:</p><br><br>
<p>
    <model name="hybris" description="...">
</p><br>
<p>
    <package name="de.hybris.jakarta.session" description="all session beans">
</p><br>
<p>
    <package name="de.hybris.jakarta.session.property">
</p><br><br>
<p>
    <object name="Property">
</p><br>
<p>
    <object-mapping>
</p><br><p>
<table name="testtable"/></p><br>
<p>
    <index name="ITEMPK">
</p><br>
<p>
    <index-key attribute="itemPK"/>
</p><br><p>                    </index></p><br>
<p>
    <index name="NAMEIDX">
</p><br>
<p>
    <index-key attribute="name"/>
</p><br><p>                    </index></p><br><p>               </object-mapping></p><br>
<p>
    <attribute name="itemPK" type="HYBRIS.PK" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="ITEMPK" null-allowed="false"/>
</p><br><p>                    </attribute></p><br>
<p>
    <attribute name="itemTypePK" type="HYBRIS.PK">
</p><br>
<p>
    <attribute-mapping persistence-name="ITEMTYPEPK" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="name" type="java.lang.String" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="NAME" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="langPK" type="HYBRIS.PK" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="LANGPK" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="realName" type="java.lang.String">
</p><br>
<p>
    <attribute-mapping persistence-name="REALNAME"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="type1" type="int">
</p><br>
<p>
    <attribute-mapping persistence-name="TYPE1"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="valueString1" type="HYBRIS.LONG_STRING">
</p><br>
<p>
    <attribute-mapping database="sqlserver" persistence-name="VALUESTRING1" persistence-type="nvarchar(1800)"/>
</p><br>
<p>
    <attribute-mapping database="oracle" persistence-name="VALUESTRING1" persistence-type="varchar2(4000)"/>
</p><br>
<p>
    <attribute-mapping persistence-name="VALUESTRING1"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="value1" type="java.io.Serializable">
</p><br>
<p>
    <attribute-mapping persistence-name="VALUE1"/>
</p><br>
<p>
    <attribute-mapping database="oracle" persistence-name="VALUE1" persistence-type="LONG RAW"/>
</p><br><p>               </attribute></p><br><p>            </object></p><br><p></p><br><p>         </package></p><br>
<br></package><br></model><br><br><p>SAP Commerce contains the Maintenance Deployment page in Administration Console
    that gives an overview of the typecodes and the deployments in use.</p><br><br><p>Advanced Deployment</p><br><p>To
    see how SAP Commerce types are mapped to different databases, see the file
    bin/platform/ext/core/resources/core-advanced-deployment.xml.</p><br><br>
<p>
    <database-schema database="hsqldb" primary-key="primary key" null="" not-null="not null">
</p><br>
<p>
    <type-mapping type="java.lang.String" persistence-type="VARCHAR(255)"/>
</p><br>
<p>
    <type-mapping type="String" persistence-type="VARCHAR(255)"/>
</p><br><br>
<p>
    <type-mapping type="java.lang.Float" persistence-type="float"/>
</p><br>
<p>
    <type-mapping type="java.lang.Double" persistence-type="double"/>
</p><br>
<p>
    <type-mapping type="java.lang.Byte" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Character" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Short" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Boolean" persistence-type="tinyint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Long" persistence-type="bigint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Integer" persistence-type="int"/>
</p><br><br>
<p>
    <type-mapping type="float" persistence-type="float default 0"/>
</p><br>
<p>
    <type-mapping type="double" persistence-type="double default 0"/>
</p><br>
<p>
    <type-mapping type="byte" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="char" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="short" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="boolean" persistence-type="tinyint default 0"/>
</p><br>
<p>
    <type-mapping type="long" persistence-type="bigint default 0"/>
</p><br>
<p>
    <type-mapping type="int" persistence-type="int default 0"/>
</p><br><br>
<p>
    <type-mapping type="java.util.Date" persistence-type="timestamp"/>
</p><br>
<p>
    <type-mapping type="java.math.BigDecimal" persistence-type="DECIMAL(30,8)"/>
</p><br>
<p>
    <type-mapping type="java.io.Serializable" persistence-type="longvarbinary"/>
</p><br><br>
<p>
    <type-mapping type="HYBRIS.LONG_STRING" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.JSON" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.COMMA_SEPARATED_PKS" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.PK" persistence-type="BIGINT"/>
</p><br><br><p>    </database-schema>Specifying a Deployment for Platform Types</p><br><p>Items within SAP Commerce are
    made persistent by writing values into a database. Within the database, the values are stored in tables. SAP
    Commerce allows you to explicitly define the database tables where the values of instances of a given type will be
    written. This process is referred to as deployment.</p><br><br><p>Technical Background</p><br><p>SAP Commerce stores
    instances of types in tables within a database. Every instance is stored as one row in a database table.</p><br><br>
<p>The table within a database where instances of a type are stored is called the type deployment and is specified with
    the type itself. Every type needs to have a deployment to store its instances. Deployment is inherited from a type
    to its subtypes. The deployment that is active for a given type is the deployment specified closest to the type in
    the type's hierarchy. The topmost deployment is GenericItem, which is therefore the default deployment. This means
    if a type has no explicit specification of deployment, that type's instances are deployed in the same table as
    GenericItem.</p><br><br><p>This means that the default deployment of any subtype, which you extend from GenericItem,
    is the deployment of GenericItem. In other words: if you do not specify a deployment for a subtype of GenericItem,
    the instances of that subtype are stored in the same table as instances of GenericItem.</p><br><br><p>For example,
    the Catalog and CronJob types in SAP Commerce are subtypes of GenericItem. If there were no deployment specified for
    Catalog and CronJob, all Catalog and CronJob instances are written into one single database table. Firstly, this is
    not intuitive. Secondly, storing instances of many different types in one single database table causes that database
    table to have quite a lot of columns to store all attributes from all these types (a CronJob has different
    attributes than a Catalog, and both types need to store attribute values).</p><br><br><p>Note</p><br><p>Specify
    Deployment for All Types</p><br><br><p>Deployment of a large number of types in a single table can markedly decrease
    the performance. Therefore, by default, builds fail if you do not specify the deployment table and you may encounter
    errors such as:</p><br><br>
<p>[ycheckdeployments] No deployment defined for relation
    <RELATIONNAME> in file:
        <FILENAME>
</p><br><p>Otherwise it would be easy to forget to specify the deployment, and, as a result, some types would go to the
    GenericItem table. The build failure reminds you that deployment is not specified for some types. To change this
    default behaviour, set the property build.development.mode to false in the local.properties file:</p><br><br><p>
    build.development.mode=false</p><br><br><p>Setting this value to false is useful for some legacy projects that
    keep all items in default tables (genericitems, links).</p><br><br><p>Keeping individual types' instances deployed
    in different tables keeps the number of columns down to a minimum.</p><br><br><p>By consequence, SAP recommends
    specifying a deployment for direct subtypes of GenericItem only. Subtypes of subtypes of GenericItem usually do not
    need a specific deployment as the number of database table columns in the deployment is not likely to get out of
    hand. In constrast, specifying a deployment for a subtype whose supertype has a deployment already is likely to
    reduce database performance (especially during long and complex database transactions, such as synchronization
    between catalog versions).</p><br><br><br><p>For example, let's assume you extend myType1 and myType2 from
    GenericItem. Then it is recommended for myType1 and for myType2 to have a specific deployment (to avoid having their
    instances stored in the GenericItem database table).</p><br><br><p>A subtype of myType1 or myType2 (for example,
    myType3 in the diagram) is not likely to also need a specific deployment. The instances of myType3 fit into the
    myType2 type's tables without any negative side effects. In fact, running FlexibleSearch statements on myType2
    requires JOINs to include the myType3 type as well. The more deployments there are within a type hierarchy, the more
    JOINs in a database statement are necessary, and the longer complex database actions take to complete.</p><br><br>
<p>In other words:</p><br><br><p>If you create a subtype of GenericItem, use a deployment.</p><br><p>If you create a
    subtype of Product, which is a subtype of GenericItem already, using a specific deployment is discouraged by SAP. It
    is technically possible to use a deployment for subtypes whose supertypes already have an individual deployment, but
    it is not recommended. The JOINs required to construct database statements reduce performance.</p><br><p>Solution:
    Defining a Deployment in SAP Commerce</p><br><p>Note</p><br><p>Database Limitations Apply</p><br><br><p>This form of
    specifying a deployment is affected by database limitations, which you have to comply with. Therefore, Platform only
    allows a deployment string of 24 characters maximum.</p><br><br><p>For example, Oracle databases only allow a
    maximum of 30 characters overall for the table attribute value.</p><br><br><p>This 30-character limit includes table
    prefixes. So if you use a table prefix of myDataBase (for a total of 10 characters), you have only 20 characters
    left for the table attribute value.</p><br><br>
<p>To specify a deployment, add a
    <deployment table="tablename" typecode="typecode_number"/>
    tag to the type definition in the items.xml file:
</p><br><br><p>Open the items.xml in your extension.</p><br><p>Locate the type definition where you want to specify a
    deployment, such as</p><br>
<p>
    <itemtype code="MyItem" extends="GenericItem">
</p><br>
<p>
    <attribute qualifier="myAttribute" ...>
</p><br><p> ...</p><br></itemtype><br><br>
<p>Add the
    <deployment> tag nested into the item definition. You need to specify a value for the deployment and the typecode
        attributes :
</p><br>
<p>
    <deployment table="mytype_deployment"/>
</p><br><br><p>The deployment attribute specifies the table name into which the instances of the type are written, such
    as table="mytype_deployment"</p><br><br><p>The typecode attribute must specify a unique number to reference the
    type. The value of the typecode attribute must be a positive integer between 0 and 32767 (2^15-1) and must be unique
    throughout SAP Commerce as it is part of the PK generation mechanism. Typecode values between 0 and 10000 are
    reserved for SAP Commerce-internal use. Typecode values larger than 10000 are generally free for you to use but
    there are lots of exceptions to that rule.</p><br><br><p>Note</p><br><p>Not all typecode values larger than 10000
    are free for you to use. There are many exceptions. Here are some examples:</p><br><br><p>commons extension
    (132xx)</p><br><br><p>processing extension (327xx)</p><br><br><p>Legacy xprint extension (244xx,245xx)</p><br><br>
<p>b2bcommerce extension (100xx)</p><br><br>
<p>For a full list of exceptions, see the
    <HYBRIS_BIN_DIR>/platform/ext/core/resources/core/unittest/reservedTypecodes.txt file.
</p><br><br><p>The entire type definition might look like this:</p><br><br>
<p>
    <item code="MyItem" extends="GenericItem">
</p><br>
<p>
    <deployment table="mytype_deployment" typecode="12345"/>
</p><br>
<p>
    <attribute name="myAttribute" ...>
</p><br><p> ...</p><br></item><br><br><p>Using a typecode that is already is use causes SAP Commerce to fail the build
    with the error message due to duplicate deployment code, as in:</p><br><br>
<p>[java] java.lang.IllegalArgumentException: cannot merge namespace ((customerreview)) into ((
    <merged>)) due to duplicate deployment code '1052' :
</p><br><p>
    de.hybris.platform.persistence.customerreview_CustomerReview::((customerreview))::YDeployment[customerreview.items.xml:51(ItemTypeTagListener)]<></p>
<br><p>
    de.hybris.platform.persistence.europe1_DiscountRow::((europe1))::YDeployment[europe1.items.xml:150(ItemTypeTagListener)]</p>
<br><br><p>Specifying or Changing Deployment for Relations</p><br><p>There are two important facts related to deployment
    for relations.</p><br><br><p>Firstly, you must specify a deployment for m:n relation, otherwise Platform will not
    build. Previously it was allowed to define an m:n relation which had no deployment. The relation was then maintained
    by the Links table. If there were multiple relations without a specified deployment, they all resided in the Links
    table. This caused bad performance and is not a good practice. Therefore, whenever you try to define an m:n relation
    without a deployment, initialisation fails with the following error:</p><br><br>
<p>[ycheckdeployments] No deployment defined for relation
    <RELATIONNAME> in file:
        <FILENAME>
</p><br><br><p>Secondly, bear in mind that Platform does not allow changing an existing deployment. This is done in
    order to protect data. If there were already some records in current deployment of a type or relation, and the
    deployment would get changed afterwards, then access would be lost to all those records.</p><br><br><p>This has a
    special consequence in conjunction with the previous paragraph (specifying a deployment), because if an m:n relation
    did not have a deployment before, and now (according to best practices) someone wants to assign it a deployment,
    this change will not be performed.</p><br><br><p>Every time Platform refuses to make a deployment change, one of the
    following messages is printed:</p><br><br><p>If there was no deployment before:</p><br>
<p>Addition of the deployment for type
    <TYPECODE> from
        <OLDDEPLOYMENT> to
            <NEWDEPLOYMENT> will not be performed; be aware that the old deployment will be still used (even though it
                is not reflected in the code base).
</p><br><br><p>If there was another deployment defined before:</p><br>
<p>Modification of the deployment for type
    <TYPECODE> from
        <OLDDEPLOYMENT> to
            <NEWDEPLOYMENT> will not be performed; be aware that the old deployment will still be used (even though it
                is not reflected in the code base).
</p><br><br><p>Using a Custom Property Table</p><br><p>If you want to use an own propertytable, you have to specify an
    own extensionname-advanced-deployment.xml in the resource folder of your extension. To use the table testtable, you
    would need the content of this file like this:</p><br><br>
<p>
    <model name="hybris" description="...">
</p><br>
<p>
    <package name="de.hybris.jakarta.session" description="all session beans">
</p><br>
<p>
    <package name="de.hybris.jakarta.session.property">
</p><br><br>
<p>
    <object name="Property">
</p><br>
<p>
    <object-mapping>
</p><br><p>
<table name="testtable"/></p><br>
<p>
    <index name="ITEMPK">
</p><br>
<p>
    <index-key attribute="itemPK"/>
</p><br><p>                    </index></p><br>
<p>
    <index name="NAMEIDX">
</p><br>
<p>
    <index-key attribute="name"/>
</p><br><p>                    </index></p><br><p>               </object-mapping></p><br>
<p>
    <attribute name="itemPK" type="HYBRIS.PK" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="ITEMPK" null-allowed="false"/>
</p><br><p>                    </attribute></p><br>
<p>
    <attribute name="itemTypePK" type="HYBRIS.PK">
</p><br>
<p>
    <attribute-mapping persistence-name="ITEMTYPEPK" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="name" type="java.lang.String" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="NAME" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="langPK" type="HYBRIS.PK" primkey-field="true">
</p><br>
<p>
    <attribute-mapping persistence-name="LANGPK" null-allowed="false"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="realName" type="java.lang.String">
</p><br>
<p>
    <attribute-mapping persistence-name="REALNAME"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="type1" type="int">
</p><br>
<p>
    <attribute-mapping persistence-name="TYPE1"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="valueString1" type="HYBRIS.LONG_STRING">
</p><br>
<p>
    <attribute-mapping database="sqlserver" persistence-name="VALUESTRING1" persistence-type="nvarchar(1800)"/>
</p><br>
<p>
    <attribute-mapping database="oracle" persistence-name="VALUESTRING1" persistence-type="varchar2(4000)"/>
</p><br>
<p>
    <attribute-mapping persistence-name="VALUESTRING1"/>
</p><br><p>               </attribute></p><br>
<p>
    <attribute name="value1" type="java.io.Serializable">
</p><br>
<p>
    <attribute-mapping persistence-name="VALUE1"/>
</p><br>
<p>
    <attribute-mapping database="oracle" persistence-name="VALUE1" persistence-type="LONG RAW"/>
</p><br><p>               </attribute></p><br><p>            </object></p><br><p></p><br><p>         </package></p><br>
<br></package><br></model><br><br><p>SAP Commerce contains the Maintenance Deployment page in Administration Console
    that gives an overview of the typecodes and the deployments in use.</p><br><br><p>Advanced Deployment</p><br><p>To
    see how SAP Commerce types are mapped to different databases, see the file
    bin/platform/ext/core/resources/core-advanced-deployment.xml.</p><br><br>
<p>
    <database-schema database="hsqldb" primary-key="primary key" null="" not-null="not null">
</p><br>
<p>
    <type-mapping type="java.lang.String" persistence-type="VARCHAR(255)"/>
</p><br>
<p>
    <type-mapping type="String" persistence-type="VARCHAR(255)"/>
</p><br><br>
<p>
    <type-mapping type="java.lang.Float" persistence-type="float"/>
</p><br>
<p>
    <type-mapping type="java.lang.Double" persistence-type="double"/>
</p><br>
<p>
    <type-mapping type="java.lang.Byte" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Character" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Short" persistence-type="smallint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Boolean" persistence-type="tinyint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Long" persistence-type="bigint"/>
</p><br>
<p>
    <type-mapping type="java.lang.Integer" persistence-type="int"/>
</p><br><br>
<p>
    <type-mapping type="float" persistence-type="float default 0"/>
</p><br>
<p>
    <type-mapping type="double" persistence-type="double default 0"/>
</p><br>
<p>
    <type-mapping type="byte" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="char" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="short" persistence-type="smallint default 0"/>
</p><br>
<p>
    <type-mapping type="boolean" persistence-type="tinyint default 0"/>
</p><br>
<p>
    <type-mapping type="long" persistence-type="bigint default 0"/>
</p><br>
<p>
    <type-mapping type="int" persistence-type="int default 0"/>
</p><br><br>
<p>
    <type-mapping type="java.util.Date" persistence-type="timestamp"/>
</p><br>
<p>
    <type-mapping type="java.math.BigDecimal" persistence-type="DECIMAL(30,8)"/>
</p><br>
<p>
    <type-mapping type="java.io.Serializable" persistence-type="longvarbinary"/>
</p><br><br>
<p>
    <type-mapping type="HYBRIS.LONG_STRING" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.JSON" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.COMMA_SEPARATED_PKS" persistence-type="LONGVARCHAR"/>
</p><br>
<p>
    <type-mapping type="HYBRIS.PK" persistence-type="BIGINT"/>
</p><br><br><p>    </database-schema></p>